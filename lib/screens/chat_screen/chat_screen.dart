import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:platonic/domains/chat_repository/src/models/models.dart';
import 'package:platonic/providers/chat_provider/action_cable_provider.dart';
import 'package:platonic/providers/chat_provider/providers.dart';
import 'package:platonic/providers/user_provider/providers.dart';
import 'package:platonic/screens/chat_screen/widgets/widgets.dart';

/* Frame chat
    Autogenerated by FlutLab FTF Generator
  */
class ChatScreen extends ConsumerWidget {
  const ChatScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final conversationState = ref.watch(chatProvider);
    final actionCableState = ref.watch(actionCableProvider);

    Future<void> toggleSend(
        {required String message, required bool emptyMessages}) async {
      // Set on meet_item or message_item
      final activeConversationUserState =
          ref.read(activeConversationUserProvider);

      // Create the message with the message, creationDate and userId
      final newMessage = Message(
          id: 0,
          message: message,
          userId: ref.read(userProvider).asData!.value.id,
          creationDate: DateTime.now().toUtc());

      // Check if exists a conversation
      if (emptyMessages == true) {
        // Create the conversation via http request
        final conversationId = await ref
            .read(chatProvider.notifier)
            .postCreateConversation(
                appUser: activeConversationUserState, message: newMessage);

        final conversation = Conversation(
            id: conversationId,
            user: activeConversationUserState,
            messages: [newMessage]);

        // Update chatProvider state
        ref
            .read(chatProvider.notifier)
            .addConversationWithMessageUpdateState(conversation: conversation);
      }
      final conversation = ref
          .read(chatProvider)
          .asData
          ?.value
          .firstWhere((e) => e.user.id == activeConversationUserState.id);

      if (conversation != null) {
        // Send the message
        ref.read(actionCableProvider.notifier).sendMessageAction(
            message: newMessage, conversationId: conversation.id);
      }
    }

    return Scaffold(
        backgroundColor: const Color.fromARGB(255, 27, 26, 29),
        body: SafeArea(
            child: conversationState.when(
          data: (data) {
            final user = ref.read(activeConversationUserProvider);
            final messages = data
                .firstWhere(
                    (conversation) =>
                        conversation.user.id ==
                        ref.read(activeConversationUserProvider).id,
                    orElse: () => Conversation.emptyConversation)
                .messages
                .reversed
                .toList();

            return Column(children: [
              Padding(
                padding: const EdgeInsets.all(16.0),
                child: SizedBox(
                  height: 40.0,
                  child: ChatTopbar(
                    appUser: user,
                  ),
                ),
              ),
              Expanded(
                child: ListView.separated(
                  reverse: true,
                  padding: const EdgeInsets.only(
                      left: 16.0, right: 16.0, bottom: 16.0),
                  itemCount: messages.length,
                  itemBuilder: (context, index) {
                    final children = <Widget>[];

                    if (index == messages.length - 1 ||
                        messages[index].creationDate.day !=
                            messages[index + 1].creationDate.day) {
                      children.add(ChatTimestampText(
                        timestamp: messages[index].creationDate,
                      ));
                      children.add(const SizedBox(height: 8.0));
                    }

                    children.add(messages[index].userId != user.id
                        ? SendedMessage(text: messages[index].message)
                        : ReceivedMessage(
                            text: messages[index].message,
                            profileImage: user.profileImage,
                          ));

                    return Column(
                      crossAxisAlignment: messages[index].userId != user.id
                          ? CrossAxisAlignment.end
                          : CrossAxisAlignment.start,
                      children: children,
                    );
                  },
                  separatorBuilder: (context, index) {
                    final currentUserId = messages[index].userId;
                    final nextUserId = index < messages.length - 1
                        ? messages[index + 1].userId
                        : null;
                    final isSameUser = currentUserId == nextUserId;

                    return SizedBox(
                      height: isSameUser ? 8.0 : 16.0,
                    );
                  },
                ),
              ),
              const SizedBox(
                height: 1.0,
              ),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16.0),
                child: ChatBottombar(
                    toggleSend: ({required String message}) => toggleSend(
                        message: message, emptyMessages: messages.isEmpty)),
              ),
              const SizedBox(
                height: 16.0,
              )
            ]);
          },
          loading: () => const Center(
            child: CircularProgressIndicator(
              color: Color.fromARGB(255, 255, 255, 255),
            ),
          ),
          error: (error, stackTrace) {
            return Text(error.toString());
          },
        )));
  }
}
