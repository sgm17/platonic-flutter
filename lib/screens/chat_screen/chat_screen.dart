import 'package:platonic/screens/error_dialog/delete_dialog/delete_dialog.dart';
import 'package:platonic/screens/error_dialog/error_dialog/error_dialog.dart';
import 'package:platonic/domains/chat_repository/src/models/models.dart';
import 'package:platonic/providers/error_provider/chat_error_provider.dart';
import 'package:platonic/providers/chat_provider/providers.dart';
import 'package:platonic/providers/user_provider/providers.dart';
import 'package:platonic/screens/chat_screen/widgets/widgets.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/material.dart';

/* Frame chat
    Autogenerated by FlutLab FTF Generator
  */
class ChatScreen extends ConsumerWidget {
  const ChatScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final chatErrorState = ref.watch(chatErrorProvider);

    // User2 set
    final activeUserState = ref.watch(activeUser2Provider);
    // Current user
    final userState = ref.watch(appUserProvider);
    // List of all the conversations
    final conversationsState = ref.watch(conversationsProvider);

    // Find the activeConversation using the current user and the activeUser
    final activeConversation = conversationsState.firstWhere(
        (e) =>
            e.user1.id == activeUserState.id && e.user2.id == userState.id ||
            e.user1.id == userState.id && e.user2.id == activeUserState.id,
        orElse: () => Conversation.emptyConversation);

    // Combine the new messages with the past
    final messages = activeConversation.messages?.reversed.toList() ?? [];

    void toggleSend({required String message}) {
      if (activeConversation == Conversation.emptyConversation) {
        // Create conversation
        final newMessage = Message(
            id: 0,
            body: message,
            userId: userState.id,
            creationDate: DateTime.now().toUtc(),
            conversationId: 0);

        ref.read(conversationsProvider.notifier).createConversation(
            user2Id: activeUserState.id, message: newMessage);
      } else {
        final newMessage = Message(
            id: 0,
            body: message,
            userId: userState.id,
            creationDate: DateTime.now().toUtc(),
            conversationId: activeConversation.id);

        ref
            .read(conversationsProvider.notifier)
            .sendMessage(message: newMessage);
      }
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (chatErrorState != null) {
        showDialog(
            context: context,
            builder: (context) => ErrorDialog(
                  error: chatErrorState.code,
                ));

        ref.read(chatErrorProvider.notifier).state = null;
      }
    });

    Future<void> toggleDeleteDialog(
      void Function() toggleDeleteConversation,
    ) async {
      return showDialog(
          context: context,
          builder: (context) => DeleteDialog(
              error: '''conversationdeletedialog''',
              toggleDelete: () {
                toggleDeleteConversation();
                Navigator.pop(context);
              }));
    }

    return Scaffold(
        backgroundColor: const Color.fromARGB(255, 27, 26, 29),
        body: SafeArea(
            child: Column(children: [
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: SizedBox(
              height: 40.0,
              child: ChatTopbar(
                  activeConversation: activeConversation,
                  appUser: activeUserState,
                  toggleDeleteDialog: toggleDeleteDialog),
            ),
          ),
          Expanded(
            child: ListView.separated(
              reverse: true,
              padding:
                  const EdgeInsets.only(left: 16.0, right: 16.0, bottom: 16.0),
              itemCount: messages.length,
              itemBuilder: (context, index) {
                final children = <Widget>[];

                if (index == messages.length - 1 ||
                    messages[index].creationDate.day !=
                        messages[index + 1].creationDate.day) {
                  children.add(ChatTimestampText(
                    timestamp: messages[index].creationDate,
                  ));
                  children.add(const SizedBox(height: 8.0));
                }

                children.add(messages[index].userId != activeUserState.id
                    ? SendedMessage(text: messages[index].body)
                    : ReceivedMessage(
                        text: messages[index].body,
                        profileImage: activeUserState.profileImage,
                      ));

                return Column(
                  crossAxisAlignment:
                      messages[index].userId != activeUserState.id
                          ? CrossAxisAlignment.end
                          : CrossAxisAlignment.start,
                  children: children,
                );
              },
              separatorBuilder: (context, index) {
                final currentUserId = messages[index].userId;
                final nextUserId = index < messages.length - 1
                    ? messages[index + 1].userId
                    : null;
                final isSameUser = currentUserId == nextUserId;

                return SizedBox(
                  height: isSameUser ? 8.0 : 16.0,
                );
              },
            ),
          ),
          const SizedBox(
            height: 1.0,
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: ChatBottombar(
              toggleSend: toggleSend,
            ),
          ),
          const SizedBox(
            height: 16.0,
          )
        ])));
  }
}
